<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
               xmlns:s="library://ns.adobe.com/flex/spark"
               width="1500" height="800"
               frameRate="10"
               addedToStage="this.init(event)">
    <fx:Declarations>
        <s:RadioButtonGroup id="gr">

        </s:RadioButtonGroup>
    </fx:Declarations>
    <fx:Script>
        <![CDATA[
        import animation.graphic.AnimationsList;
        import animation.graphic.RotateEnum;
        import animation.library.AnimationLibrary;
        import animation.library.AssetLibrary;
        import animation.library.SWFLibraryTemp;

        import dzyga.events.Action;
        import dzyga.events.EnterFrame;

        import mx.controls.Alert;

        import spark.components.RadioButton;
        import spark.components.RadioButtonGroup;

        private var _url:String;
        [Bindable]
        private var animationSpeed:String = '800';

        public function init(e:Event):void {
            EnterFrame.dispatcher = this.stage;
            EnterFrame.fps = 24;
            var gr:Graphics = fillGr.graphics;
            gr.beginFill(0xFFFFFF);
            gr.drawRect(5, 110, 160, 250);

            _name = loaderInfo.loaderURL.split('AssetViewer.swf?id=')[1];
            _url = loaderInfo.loaderURL.split('AssetViewer.swf?id=')[0];
            if (_name) {
                _url = _url + 'assets/' + _name + '.swf';
                var loader:Loader = new Loader();
                loader.load(new URLRequest(_url));
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadBytes);
                loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errLoad);
            }

            AnimationSettings.previewMode = true;
        }

        private function errLoad(event:IOErrorEvent):void {
            Alert.show(_name + ' не существует на сервере :' + _url);
        }

        private var _loadFile:FileReference;

        private function selectFileStartHandler(event:MouseEvent):void {
            if (asset) {
                asset.cleanUp();
                monitor.removeChild(asset);
            }
            if (_loadFile) {
                _loadFile.cancel();
            }
            _loadFile = new FileReference();
            _loadFile.addEventListener(Event.SELECT, fileSelectHandler);
            var fileFilter:FileFilter = new FileFilter("Flash Movie: (*.swf)", "*.swf");
            _loadFile.browse([fileFilter]);
        }

        private function fileSelectHandler(event:Event):void {
            _loadFile.removeEventListener(Event.SELECT, fileSelectHandler);
            _loadFile.addEventListener(Event.COMPLETE, onFileLoad);
            _loadFile.load();
        }

        protected function onFileLoad(event:Event):void {
            _loadFile.removeEventListener(Event.COMPLETE, onFileLoad);
            _name = _loadFile.name.replace('.swf', '');
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.INIT, loadBytes, false, 0, true);
            var lc:LoaderContext = new LoaderContext(false);
            lc.allowCodeImport = true;
            loader.loadBytes(_loadFile.data, lc);
            _loadFile = null;
        }

        private var asset:BaseAssetView;
        private static const LIB_PROP:String = 'library';
        private var currentType:int = 0;
        private var clip:MovieClip;
        private var _name:String;
        private var clipClass:Class;

        protected function loadBytes(event:Event):void {
            var loaderInfo:LoaderInfo = (event.target as LoaderInfo);
            loaderInfo.removeEventListener(Event.COMPLETE, loadBytes);
            clip = loaderInfo.content as MovieClip;
            try {
                clipClass = loaderInfo.applicationDomain.getDefinition(_name) as Class;
            } catch (err:Error) {
                Alert.show(_name + ' некорректное имя внутри');
            }

            loadMap();
        }

        private function loadMap():void {
            SWFLibraryTemp.addSource(_name, clipClass);
            var assetClip:MovieClip = new clipClass;
            AssetLibrary._sourceByName[_name] = assetClip;
            AnimationLibrary.parseWyseClip(assetClip, _name);
            asset = new BaseAssetView(_name, AssetTypes.WORKER);

            var animationQuery:AnimationModel = AnimationLibrary.getAnimationQueryInstance(_name, AnimationsList.IDLE, 1);
            asset.setAnimation(animationQuery);
            /*rotateBack.enabled = animationQuery._currentPreset().isRotateSupport(PositionEnum.BACK);
             rotateCorner.enabled = animationQuery._currentPreset().isRotateSupport(PositionEnum.CORNER);
             rotateFlip.enabled = animationQuery._currentPreset().isRotateSupport(RotateEnum.FLIP);*/
            monitor.addChild(asset);
            asset.isOnStage = true;
            showMapSelectors();
        }

        private var _radioGroup:RadioButtonGroup;

        private function showMapSelectors():void {
            if (_radioGroup) {
                while (_radioGroup.numRadioButtons) {
                    var btn:RadioButton = _radioGroup.getRadioButtonAt(0);
                    btn.group = null;
                    removeElement(btn);
                }
                _radioGroup = null;
            }

            _radioGroup = new RadioButtonGroup();
            var mapStates:Array = AnimationLibrary['_animationPresetList'][_name];

            var temp:int = 0;
            for (var i:int = 0; i < mapStates.length; i++) {
                var step:Object = mapStates[i];
                if (step) {
                    var animations:Object = step['animations'];
                    for each (var anim:String in animations) {
                        temp++;
                        var rb:RadioButton = new RadioButton();
                        rb.x = 1150;
                        rb.y = 130 + 13 * temp;
                        rb.label = i + ') ' + anim;
                        rb.value = anim + '_|_' + i;
                        addElement(rb);
                        rb.group = _radioGroup;
                        rb.addEventListener(MouseEvent.CLICK, selectStateHandler);
                    }
                }
            }

            var gr:Graphics = fillGr.graphics;
            gr.beginFill(0xFFFFFF);
            gr.drawRect(1120, 110, 230, 350);
            gr.endFill();
        }

        private function selectStateHandler(event:MouseEvent):void {
            selectState(_radioGroup.selectedValue.split('_|_')[0], _radioGroup.selectedValue.split('_|_')[1]);
        }

        private var moveAction:Action;

        private function selectState(animation:String, step:uint):void {
            var animationQuery:AnimationModel = AnimationLibrary.getAnimationQueryInstance(_name, animation, step);
            //animationQuery.loopCount = 1;

            /*rotateBack.enabled = animationQuery._currentPreset().isRotateSupport(PositionEnum.BACK);
             rotateCorner.enabled = animationQuery._currentPreset().isRotateSupport(PositionEnum.CORNER);
             rotateFlip.enabled = animationQuery._currentPreset().isRotateSupport(RotateEnum.FLIP);*/

            asset.setAnimation(animationQuery);
            if (this.moveAction) {
                EnterFrame.removeAction(this.moveAction);
                this.moveAction = null;
            }
            asset.x = 0;
            asset.y = 0;
            _walkStartTime = getTimer();
            var guide:Graphics = moveGuide.graphics;
            guide.clear();
            guide.lineStyle(1, 0xFF0000, 0.7);
            asset.speed = 800 / int(animationSpeed);
            switch (animation) {
                case AnimationsList.BACK_SIDE_WALK:
                    _walkTime = int(animationSpeed) * Point.distance(new Point(CELL_DX * 6, 0),
                            new Point(0, CELL_DY * 6)) / DEFAULT_DISTANCE / 2;
                    this.moveAction = EnterFrame.addAction(0, this.moveHelper, null, CELL_DX * 6, -CELL_DY * 6);
                    guide.moveTo(0, 0);
                    guide.lineTo(CELL_DX * 6, -CELL_DY * 6);
                    break;
                case AnimationsList.BACK_WALK:
                    _walkTime = int(animationSpeed) * CELL_DY * 6 / DEFAULT_DISTANCE;
                    this.moveAction = EnterFrame.addAction(0, this.moveHelper, null, 0, -CELL_DY * 12);
                    guide.moveTo(0, 0);
                    guide.lineTo(0, -CELL_DY * 12);
                    break;
                case AnimationsList.FORWARD_SIDE_WALK:
                    _walkTime = int(animationSpeed) * Point.distance(new Point(CELL_DX * 6, 0),
                            new Point(0, CELL_DY * 6)) / DEFAULT_DISTANCE / 2;
                    this.moveAction = EnterFrame.addAction(0, this.moveHelper, null, CELL_DX * 6, CELL_DY * 6);
                    guide.moveTo(0, 0);
                    guide.lineTo(CELL_DX * 6, CELL_DY * 6);
                    break;
                case AnimationsList.FORWARD_WALK:
                    _walkTime = int(animationSpeed) * CELL_DY * 6 / DEFAULT_DISTANCE;
                    this.moveAction = EnterFrame.addAction(0, this.moveHelper, null, 0, CELL_DY * 12);
                    guide.moveTo(0, 0);
                    guide.lineTo(0, CELL_DY * 12);
                    break;
                case AnimationsList.SIDE_WALK:
                    _walkTime = int(animationSpeed) * CELL_DX * 6 / DEFAULT_DISTANCE / 2;
                    this.moveAction = EnterFrame.addAction(0, this.moveHelper, null, CELL_DX * 6, 0);
                    guide.moveTo(0, 0);
                    guide.lineTo(CELL_DX * 6, 0);
                    break;
                default:
                    asset.speed = 1;
                    break;
            }
        }

        private var _walkTime:Number;
        private var _walkStartTime:Number;

        private function moveHelper(dx:Number, dy:Number):void {
            var time:Number = getTimer();
            if (_walkStartTime + _walkTime < time) {
                _walkStartTime = time;
            }
            var prg:Number = (time - _walkStartTime) / _walkTime;
            if (dx != 0) {
                asset.x = dx * prg;
            }
            if (dy != 0) {
                asset.y = dy * prg;
            }
        }

        private function setRotate(value:String):void {
            asset.rotate = value;
        }

        public static const DEFAULT_DISTANCE:int = Math.sqrt(CELL_WIDTH * CELL_WIDTH + CELL_HEIGHT * CELL_HEIGHT) / 2;
        public static const CELL_WIDTH:int = 90;
        public static const CELL_HEIGHT:int = 45;
        public static const CELL_DX:int = CELL_WIDTH / 2;
        public static const CELL_DY:int = CELL_HEIGHT / 2;
        ]]>
    </fx:Script>
    <s:SpriteVisualElement id="dd"/>
    <s:BitmapImage source="@Embed('../assets/assetViewerBg.PNG')" visible="{bitmapBox.selected}"/>
    <s:SpriteVisualElement id="fillGr"/>
    <s:SpriteVisualElement id="moveGuide" x="670" y="335" visible="{guideBox.selected}"/>
    <s:Button id="map" label="select file" x="10" y="130" click="selectFileStartHandler(event)"/>
    <s:VGroup y="170">
        <s:CheckBox x="10" id="bitmapBox" label="show background image" selected="true"/>
        <s:CheckBox x="10" id="guideBox" label="show red move guide" selected="true"/>
        <s:Button x="10" id="rotate" label=" flip" click="{setRotate(RotateEnum.FLIP)}"/>
        <s:Button x="10" id="rotateNone" label="rotate none" click="{setRotate(RotateEnum.NONE)}"/>
        <s:TextInput text="{animationSpeed}" change="{animationSpeed = speedInput.text}" id="speedInput" />
    </s:VGroup>
    <s:SpriteVisualElement id="monitor" x="670" y="335"/>
</s:Application>
